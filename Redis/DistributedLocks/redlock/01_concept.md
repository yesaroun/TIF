# RedLock (Redis Distributed Lock)

## 개요

RedLock은 Redis를 사용한 분산 락(Distributed Lock) 알고리즘입니다. Redis의 창시자인 Salvatore Sanfilippo(antirez)가 제안한 알고리즘으로, 여러 Redis 인스턴스를 사용하여 안전한 분산 락을 구현합니다.

## 왜 필요한가?

### 분산 시스템에서의 문제

분산 시스템에서 여러 프로세스나 서버가 공유 자원에 동시에 접근하려 할 때 발생하는 문제:

- **Race Condition**: 여러 프로세스가 동시에 같은 자원을 수정
- **데이터 불일치**: 동시 작업으로 인한 데이터 손상
- **중복 작업**: 같은 작업이 여러 번 실행됨

### 예시 시나리오

```
상황: 주문 처리 시스템

문제 없는 경우:
Server A: 주문 #123 처리 시작 → 재고 확인 (10개) → 재고 차감 (9개) → 주문 완료

문제 발생 경우:
Server A: 주문 #123 처리 시작 → 재고 확인 (10개)
Server B: 주문 #124 처리 시작 → 재고 확인 (10개) ← 동시에 확인!
Server A: 재고 차감 (9개)
Server B: 재고 차감 (9개) ← 8개가 되어야 하는데 9개!
```

## RedLock 알고리즘

### 기본 원리

단일 Redis 인스턴스가 아닌 **여러 개의 독립적인 Redis 마스터** 인스턴스를 사용합니다.

### 알고리즘 단계

1. **현재 시간 기록** (밀리초 단위)

2. **순차적으로 모든 Redis 인스턴스에 락 획득 시도**
   - 각 인스턴스에 `SET resource_name my_random_value NX PX 30000` 명령 실행
   - `NX`: 키가 없을 때만 설정
   - `PX`: 만료 시간 설정 (밀리초)
   - 타임아웃: 전체 락 만료 시간보다 훨씬 짧게 설정 (예: 5-50ms)

3. **락 획득 성공 여부 확인**
   - **과반수 이상**(N/2 + 1)의 인스턴스에서 락을 획득했는가?
   - 락 획득에 걸린 시간이 락 유효 시간보다 짧은가?

4. **성공 시**: 락 사용 (유효 시간 = 초기 설정 시간 - 획득에 걸린 시간)

5. **실패 시**: 모든 인스턴스에서 락 해제 후 재시도

### 시각적 설명

```
5개의 Redis 인스턴스가 있다고 가정:

시도 1 (성공):
Redis 1: ✓ 락 획득 (5ms)
Redis 2: ✓ 락 획득 (3ms)
Redis 3: ✓ 락 획득 (7ms)  ← 3개 이상 획득 성공!
Redis 4: ✗ 실패 (타임아웃)
Redis 5: ✗ 실패 (이미 락 존재)
→ 과반수(3/5) 획득 → 락 사용 가능

시도 2 (실패):
Redis 1: ✓ 락 획득 (5ms)
Redis 2: ✗ 실패
Redis 3: ✗ 실패
Redis 4: ✗ 실패
Redis 5: ✓ 락 획득 (4ms)
→ 과반수 미달(2/5) → 모든 락 해제 후 재시도
```

## 핵심 특징

### 1. 랜덤 값 (Random Value)

```
SET lock:order:123 "d8f7a3b2-4c1e-4d9f-8a2b-3c4d5e6f7a8b" NX PX 30000
                    ↑ 클라이언트 고유 랜덤 값
```

**이유**: 자신이 획득한 락만 해제할 수 있도록 보장

### 2. 자동 만료 (Auto Expiration)

- 클라이언트가 죽어도 락이 자동으로 해제됨
- **만료 시간 설정이 중요**: 너무 짧으면 작업 중 락이 풀림, 너무 길면 장애 시 대기 시간 증가

### 3. 과반수 합의 (Quorum)

- N개 중 N/2 + 1개 이상에서 락을 획득해야 함
- **이유**: 네트워크 분할(split-brain) 상황에서도 안전성 보장

## 안전성 보장

### Clock Drift 문제

분산 시스템에서 각 서버의 시계가 다를 수 있습니다.

```
Server A 시계: 12:00:00.000
Server B 시계: 12:00:00.100 (100ms 빠름)
```

**RedLock의 해결책**:
- 락 유효 시간에서 시계 오차를 뺀 시간만큼만 사용
- 예: 락 시간 10초, 시계 오차 최대 1% → 실제 사용 시간 9.9초

### 재시도 전략

- 실패 시 **랜덤 딜레이** 후 재시도
- **이유**: 모든 클라이언트가 동시에 재시도하는 것 방지 (Thundering Herd)

## 장단점

### 장점

- ✓ **높은 가용성**: 일부 Redis 인스턴스가 죽어도 동작
- ✓ **안전성**: 과반수 합의로 동시 락 획득 방지
- ✓ **자동 복구**: 클라이언트 장애 시 자동으로 락 해제

### 단점

- ✗ **복잡성**: 단일 Redis보다 설정 및 운영이 복잡
- ✗ **비용**: 최소 3개, 권장 5개의 Redis 인스턴스 필요
- ✗ **논쟁**: Martin Kleppmann의 비판 (fencing token 부재)
- ✗ **시계 의존성**: 시스템 시계의 정확성에 의존

## 대안

### 1. 단일 Redis (Simple Lock)
- **장점**: 간단, 빠름
- **단점**: SPOF(단일 장애점)
- **사용 사례**: 중요하지 않은 작업, 개발 환경

### 2. Redisson (Java)
- RedLock 구현체
- 추가 기능: 공정한 락, 읽기/쓰기 락

### 3. etcd / ZooKeeper
- **장점**: 강력한 일관성 보장, fencing token 지원
- **단점**: 더 무겁고 복잡함
- **사용 사례**: 매우 중요한 분산 락이 필요한 경우

### 4. Database Lock
- **장점**: 별도 인프라 불필요
- **단점**: 성능 저하, 확장성 제한
- **사용 사례**: 소규모 시스템

## 언제 사용할까?

### RedLock 사용 권장

- 중간 정도의 중요도를 가진 분산 락이 필요할 때
- 높은 가용성이 필요할 때
- Redis 인프라가 이미 구축되어 있을 때

### 사용 예시

1. **주기적 작업 (Cron Job)**
   ```
   여러 서버에서 동일한 스케줄러가 실행될 때
   한 서버만 작업을 수행하도록 보장
   ```

2. **재고 관리**
   ```
   동시 주문 처리 시 재고 차감을 안전하게 수행
   ```

3. **캐시 갱신**
   ```
   캐시 만료 시 여러 요청이 동시에 DB를 조회하지 않도록
   (Cache Stampede 방지)
   ```

4. **분산 작업 큐**
   ```
   여러 워커가 같은 작업을 중복 처리하지 않도록
   ```

## Martin Kleppmann의 비판

분산 시스템 전문가 Martin Kleppmann은 RedLock의 안전성에 의문을 제기했습니다.

### 주요 비판 내용

1. **Fencing Token 부재**
   ```
   Client A: 락 획득 → GC pause (긴 정지) → 락 만료
   Client B: 락 획득 → 작업 시작
   Client A: GC 복구 → 작업 계속 (자신의 락이 유효하다고 착각)
   → 두 클라이언트가 동시에 작업 수행!
   ```

2. **시계 동기화 문제**
   - 시스템 시계가 갑자기 점프하면 안전성 보장 불가

### Fencing Token이란?

```
Redis가 증가하는 숫자(토큰)를 함께 제공:

Client A: 락 획득 (token: 33)
Client A: 작업 시작 (token: 33 전송)
Client A: GC pause
Client B: 락 획득 (token: 34)
Client B: 작업 시작 (token: 34 전송)
Client A: 복구 후 작업 시도 (token: 33 전송)

→ 서버가 token: 33을 거부 (이미 token: 34를 받았으므로)
```

### RedLock 개발자의 반론

antirez는 다음과 같이 반론했습니다:
- RedLock은 "효율성"과 "안전성" 사이의 실용적 균형점
- 완벽한 안전성이 필요하다면 Raft/Paxos 기반 시스템(etcd, ZooKeeper) 사용 권장
- 대부분의 실무 사용 사례에서는 충분히 안전함

## 실무 권장 사항

1. **중요도 평가**
   - 낮음: 단일 Redis 락
   - 중간: RedLock
   - 높음: etcd/ZooKeeper

2. **모니터링 필수**
   - 락 획득 실패율
   - 락 대기 시간
   - 락 만료로 인한 실패

3. **타임아웃 설정**
   - 작업 시간의 2-3배로 설정
   - 너무 길면 장애 시 복구 지연
   - 너무 짧으면 작업 중 락 만료

4. **재시도 전략**
   - 지수 백오프 (Exponential Backoff)
   - 최대 재시도 횟수 제한

## 다음 단계

- `02_implementations.py`: Python으로 RedLock 구현하기
- `03_patterns.md`: 실무 사용 패턴 및 모범 사례
- `04_advanced.md`: 고급 주제 및 최적화
