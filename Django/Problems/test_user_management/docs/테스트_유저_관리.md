# 테스트 유저 관리

## 문제 정의

### 배경
실제 사용자 데이터(홈택스, 금융 정보 등)를 연동하는 서비스에서 테스트 시 다음과 같은 제약사항이 발생합니다

- **단일 테스터의 한계**: 한 명의 테스터가 모든 비즈니스 시나리오를 테스트할 수 없음
    - 예: 환급액이 있는 경우 vs 없는 경우
    - 예: 홈택스 가입자 vs 미가입자

### 기존 접근 방식의 문제점

```python
# 문제가 있는 기존 코드 (views.py의 레거시 버전)
TEST_EMAILS = [
    "test1@company.com",
    "test2@company.com",
]

if user.email in TEST_EMAILS:
    # 특정 플로우 강제 실행
    return mock_data
```

**한계점**:
- 코드 수정 없이 테스트 케이스 변경 불가
- 테스터와 시나리오 매핑 관리 어려움
- 모든 테스트 유저가 동일한 시나리오만 테스트 가능
- 새로운 테스트 케이스 추가 시 코드 배포 필요

---

## 해결 방안: 데이터베이스 기반 동적 관리

### 아키텍처 설계

```
┌─────────────┐      M:N       ┌──────────────┐
│    User     │◄──────────────►│  TestCase    │
└─────────────┘                └──────────────┘
       ▲                              │
       │                              │
       └──────────────────────────────┘
              UserTestCaseAssignment
```

### 핵심 아이디어

1. **테스트 케이스를 DB에 저장**: 코드가 아닌 데이터로 관리
2. **유저-시나리오 매핑**: 유연한 M:N 관계로 다양한 조합 가능
3. **환경 분리**: 프로덕션에서는 완전히 비활성화

---

## 프로젝트 구조

```
test_user_management/
├── apps/
│   ├── test_manager/          # 테스트 관리 앱
│   │   ├── models.py          # TestCase, UserTestCaseAssignment 모델
│   │   └── utils.py           # is_test_user_for_scenario() 유틸리티
│   └── user/
│       └── models.py          # Custom User 모델
├── services/
│   ├── external_api.py        # 외부 API 연동 (홈택스 등)
│   └── calculation.py         # 환급 계산 비즈니스 로직
├── api/
│   └── v1/
│       └── test_manager/
│           └── views.py       # 환급 처리 뷰 (레거시 vs 개선)
└── config/
    └── settings.py            # IS_PRODUCTION 설정
```

---

## 핵심 구현 코드

### 모델 정의 (`apps/test_manager/models.py`)

```python
from django.db import models
from django.db.models import TextChoices


class UserTestCaseNames(TextChoices):
    """
    데이터베이스 'test_cases' 테이블의 'name' 컬럼에 있는 값들을
    코드에서 안전하게 사용하기 위해 정의하는 상수 목록입니다.

    이 목록을 바꾼다고 해서 마이그레이션이 필요하지는 않지만,
    DB와 항상 일치하도록 개발자가 직접 관리해야 합니다.
    """
    NOT_HOMETAX_MEMBER = ("NotHomeTaxMember", "홈택스 미가입자")
    MONTHLY_RENT_REFUND_AMOUNT = ("MonthlyRentRefundAmount", "월세 환급액 존재")


class TestCase(models.Model):
    """테스트 시나리오 정의"""
    name = models.CharField(
        max_length=100,
        unique=True,
        verbose_name="테스트 케이스 이름",
        help_text="코드에서 사용할 테스트 케이스 키 (예: NotHomeTaxMember)",
    )
    users = models.ManyToManyField(
        "user.User",
        through="UserTestCaseAssignment",
        related_name="test_cases",
        blank=True,
        verbose_name="테스트 유저들",
    )

    class Meta:
        db_table = "test_cases"


class UserTestCaseAssignment(models.Model):
    """유저-테스트케이스 매핑"""
    user = models.ForeignKey("user.User", on_delete=models.CASCADE)
    test_case = models.ForeignKey("TestCase", on_delete=models.CASCADE)
    assigned_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        db_table = "user_test_case_assignments"
        unique_together = ["user", "test_case"]
```

**주요 특징**:
- `UserTestCaseNames`: 코드에서 사용할 상수 정의 (타입 안전성)
- `TestCase`: 최소한의 필드만 유지 (name만 필수)
- `UserTestCaseAssignment`: Through 모델로 매핑 관리

### 핵심 유틸리티 함수 (`apps/test_manager/utils.py`)

```python
from django.conf import settings
from apps.test_manager.models import UserTestCaseAssignment


def is_test_user_for_scenario(user_id: int, scenario: str) -> bool:
    """
    특정 유저가 특정 테스트 시나리오에 할당되었는지 확인
    개발/스테이징 환경에서만 동작

    Args:
        user_id: 확인할 유저 ID
        scenario: 테스트 시나리오 이름 (예: "NOT_HOMETAX_MEMBER")

    Returns:
        bool: 테스트 유저 여부
    """
    # 프로덕션에서는 항상 False 반환
    if settings.IS_PRODUCTION:
        return False

    try:
        return UserTestCaseAssignment.objects.filter(
            user_id=user_id,
            test_case__name=scenario
        ).exists()
    except Exception:
        # 테이블이 없거나 에러 발생 시 안전하게 False 반환
        return False
```

**안전 장치**:
1. 프로덕션 환경 체크 (`IS_PRODUCTION`)
2. 예외 처리로 안전한 폴백

---

## 실제 사용 예시

### 외부 API 연동 (`services/external_api.py`)

```python
from django.conf import settings
from apps.test_manager.utils import is_test_user_for_scenario


def check_hometax_registration(user_id: int):
    """홈택스 가입 여부 확인"""
    # 프로덕션이 아닌 경우에만 테스트 유저 체크
    if not settings.IS_PRODUCTION:
        if is_test_user_for_scenario(user_id, "NOT_HOMETAX_MEMBER"):
            return {"registered": False}

    # 실제 외부 API 호출
    response = external_api_call(user_id)
    return response


def external_api_call(user_id: int):
    """실제 외부 API 호출"""
    return {
        "registered": True,
        "user_id": user_id,
        "registration_date": "2024-01-15"
    }
```

### 환급 계산 로직 (`services/calculation.py`)

```python
from django.conf import settings
from apps.test_manager.utils import is_test_user_for_scenario


def calculate_refund(user_id: int):
    """환급액 계산 - 테스트 시나리오 포함"""
    # 프로덕션이 아닌 경우에만 테스트 유저 체크
    if not settings.IS_PRODUCTION:
        # 테스트 유저용 특별 처리
        if is_test_user_for_scenario(user_id, "MONTHLY_RENT_REFUND"):
            # 항상 환급액이 있는 시나리오
            return {"amount": 1_500_000, "reason": "월세 환급 테스트"}

    # 실제 계산 로직
    income = get_user_income(user_id)
    if income > 70_000_000:
        return {"amount": 0, "reason": "소득 초과"}

    return calculate_actual_refund(user_id)


def get_user_income(user_id: int) -> int:
    """사용자 소득 조회"""
    return 50_000_000  # 실제로는 DB나 외부 API에서 조회


def calculate_actual_refund(user_id: int) -> dict:
    """실제 환급액 계산"""
    income = get_user_income(user_id)

    if income > 70_000_000:
        return {"amount": 0, "reason": "소득 초과"}
    elif income > 50_000_000:
        return {"amount": 500_000, "reason": "부분 환급"}
    else:
        return {"amount": 1_000_000, "reason": "전액 환급"}
```

### 뷰에서 활용 (`api/v1/test_manager/views.py`)

```python
from django.http import JsonResponse
from django.contrib.auth.decorators import login_required
from django.views.decorators.http import require_http_methods

from services.external_api import check_hometax_registration
from services.calculation import calculate_refund


@login_required
@require_http_methods(["GET"])
def process_refund(request):
    """환급 처리 전체 플로우 - 개선된 버전"""
    user_id = request.user.id

    try:
        # 1. 홈택스 가입 확인 (내부에서 테스트 유저 체크)
        hometax_status = check_hometax_registration(user_id)

        # 2. 환급액 계산 (내부에서 테스트 유저 체크)
        refund_amount = calculate_refund(user_id)

        return JsonResponse({
            "success": True,
            "user": request.user.username,
            "hometax_status": hometax_status,
            "refund_amount": refund_amount,
        })

    except Exception as e:
        return JsonResponse(
            {"success": False, "error": "UNKNOWN_ERROR", "message": str(e)},
            status=500
        )
```

---

## Before/After 비교

### Before: 이메일 하드코딩 방식

```python
# api/v1/test_manager/views.py - 레거시 버전

TEST_EMAILS = [
    "test1@company.com",
    "test2@company.com",
    "test_hometax@company.com",
    "test_refund@company.com",
]


@login_required
@require_http_methods(["GET"])
def process_refund_legacy(request):
    """환급 처리 - 레거시 버전 (이메일 하드코딩 방식)"""
    user = request.user
    user_id = user.id

    # 테스트 유저 체크 (이메일 기반)
    if user.email in TEST_EMAILS:
        # 특정 플로우 강제 실행 - Mock 데이터 반환
        return JsonResponse({
            "success": True,
            "user": user.username,
            "hometax_status": {"registered": False, "is_test": True},
            "refund_amount": {"amount": 1_500_000, "is_test": True},
            "message": "테스트 유저 - Mock 데이터 반환",
        })

    try:
        # 실제 유저인 경우 정상 플로우
        hometax_status = check_hometax_registration(user_id)
        refund_amount = calculate_refund(user_id)

        return JsonResponse({
            "success": True,
            "user": user.username,
            "hometax_status": hometax_status,
            "refund_amount": refund_amount,
        })

    except Exception as e:
        return JsonResponse(
            {"success": False, "error": "UNKNOWN_ERROR", "message": str(e)},
            status=500
        )
```

**문제점**:
1. 모든 테스트 유저가 **동일한 시나리오**만 테스트
2. 코드 수정 없이 **테스트 케이스 변경 불가**
3. 새 테스터 추가 시 **코드 배포 필요**
4. 뷰 레이어에 **비즈니스 로직 침투**

### After: DB 기반 동적 관리

```python
# api/v1/test_manager/views.py - 개선된 버전

@login_required
@require_http_methods(["GET"])
def process_refund(request):
    """환급 처리 전체 플로우"""
    user_id = request.user.id

    try:
        # 1. 홈택스 가입 확인
        hometax_status = check_hometax_registration(user_id)

        # 2. 환급액 계산
        refund_amount = calculate_refund(user_id)

        return JsonResponse({
            "success": True,
            "user": request.user.username,
            "hometax_status": hometax_status,
            "refund_amount": refund_amount,
        })

    except Exception as e:
        return JsonResponse(
            {"success": False, "error": "UNKNOWN_ERROR", "message": str(e)},
            status=500
        )
```

```python
# services/external_api.py - 비즈니스 로직에서 처리

def check_hometax_registration(user_id: int):
    """홈택스 가입 여부 확인"""
    if not settings.IS_PRODUCTION:
        if is_test_user_for_scenario(user_id, "NOT_HOMETAX_MEMBER"):
            return {"registered": False}

    return external_api_call(user_id)
```

**개선 사항**:
1. **유연성**: Admin에서 유저-시나리오 매핑 자유롭게 변경
2. **확장성**: 새로운 테스트 케이스를 DB에만 추가
3. **안전성**: 프로덕션에서 완전히 비활성화

---
