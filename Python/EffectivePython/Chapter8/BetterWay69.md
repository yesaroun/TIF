# Better Way 69 정확도가 매우 중요한 경우에는 decimal을 사용하라

파이썬의 정수(`int`) 타입은 사실상 모든 크기의 값을 표현할 수 있고, 배정밀도 부동소수점(`float`) 타입은 IEEE 754 표준을 따른다. 또한, 허수를 위한 표준 복소수(`complex`) 타입도 제공한다. 하지만 이것만으로는 모든 상황에 충분하지 않다.

예를 들어, 국제전화 요금을 계산하는 경우를 생각해보자. 고객이 3분 42초 동안 통화했고, 분당 요금은 $1.45$라고 가정했다. 부동소수점으로 요금을 계산하면 다음과 같은 결과가 나왔다.

```python
rate = 1.45
seconds = 3*60 + 42
cost = rate * seconds / 60
print(cost)
# 결과: 5.364999999999999
```

이 결과는 IEEE 754 부동소수점 숫자의 표현 방식 때문에 정확한 값($5.365$)보다 $0.0001$만큼 작게 나왔다. 이 값을 올림하여 $5.37$로 만들고 싶지만, 부동소수점 오류 때문에 `round()` 함수는 오히려 값을 내리는 결과를 초래했다.

```python
print(round(cost, 2))
# 결과: 5.36
```

이 문제의 해결책은 `decimal` 내장 모듈의 `Decimal` 클래스를 사용하는 것이다. `Decimal` 클래스는 기본적으로 28자리의 십진수 정밀도를 제공하는 고정 소수점 연산을 수행하며, 필요에 따라 정밀도를 더 높일 수도 있다. 이를 통해 IEEE 754 부동소수점의 정밀도 문제를 피하고, 반올림 방식도 더 세밀하게 제어할 수 있다.

`Decimal`을 사용하여 다시 계산하면 근사치가 아닌 정확한 예상 요금을 얻을 수 있다.

```python
from decimal import Decimal

rate = Decimal('1.45')
seconds = Decimal(3*60 + 42)
cost = rate * seconds / Decimal(60)
print(cost)
# 결과: 5.365
```

`Decimal` 인스턴스를 생성할 때는 두 가지 방법이 있다. 첫 번째는 숫자를 문자열(`str`)로 전달하는 것이고, 두 번째는 `float`나 `int` 인스턴스를 직접 전달하는 것이다. 부동소수점의 내재적 오류를 피하고 정밀도를 보장하려면 문자열로 생성하는 방식이 바람직하다. 두 방식의 차이는 다음과 같다.

```python
print(Decimal('1.45'))
# 결과: 1.45

print(Decimal(1.45))
# 결과: 1.4499999999999999555910790149937383830547332763671875
```

정수를 전달할 때는 이러한 문제가 발생하지 않는다. 정확한 답이 중요하다면 `Decimal` 타입을 생성할 때 문자열(`str`)을 사용하는 것이 안전하다.

이제 요금이 매우 저렴하고 통화 시간이 짧은 경우를 생각해보자. 분당 $0.05$의 요금으로 5초간 통화한 비용을 계산했다.

```python
rate = Decimal('0.05')
seconds = Decimal('5')
small_cost = rate * seconds / Decimal(60)
print(small_cost)
# 결과: 0.004166666666666666666666666667
```

이 결과는 너무 작아서 센트 단위로 반올림하면 $0.00$이 되어 버린다.

다행히 `Decimal` 클래스에는 `quantize`라는 메서드가 내장되어 있어, 원하는 반올림 방식과 자리 수를 정확히 지정할 수 있다. 이 메서드는 앞서 계산했던 높은 비용의 경우에도 잘 동작한다.

```python
from decimal import ROUND_UP

rounded = cost.quantize(Decimal('0.01'), rounding=ROUND_UP)
print(f'Rounded {cost} to {rounded}')
# 결과: Rounded 5.365 to 5.37
```

`quantize` 메서드를 사용하면 통화 시간이 짧고 저렴한 경우에도 비용을 올바르게 처리할 수 있다.

```python
rounded = small_cost.quantize(Decimal('0.01'), rounding=ROUND_UP)
print(f'Rounded {small_cost} to {rounded}')
# 결과: Rounded 0.004166666666666666666666666667 to 0.01
```

`Decimal`은 고정 소수점 수에 매우 유용하지만, $1/3$과 같이 무한히 반복되는 소수를 표현할 때는 여전히 근사치를 사용한다는 한계가 있다. 정밀도에 제한이 없는 유리수를 표현해야 할 때는 `fractions` 내장 모듈의 `Fraction` 클래스를 사용하는 것을 고려해야 한다.

#### 기억해야 할 내용

  * 파이썬은 모든 종류의 수치 값을 표현할 수 있는 내장 타입과 클래스를 갖추고 있다.
  * `Decimal` 클래스는 금융 계산과 같이 높은 정밀도와 반올림 방식에 대한 제어가 필요한 상황에 이상적이다.
  * 부동소수점 근사치가 아닌 정확한 답을 계산하려면 `Decimal` 생성자에 `float` 대신 `str` 인스턴스를 전달해야 한다.

### 참고) 부동소수점

컴퓨터가 부동소수점 숫자를 처리할 때 미세한 오차가 발생하는 이유는 다음과 같이 정리할 수 있다.

#### 1. 이진법 표현의 한계
컴퓨터는 우리가 일상에서 사용하는 십진법이 아닌 **이진법**으로 모든 숫자를 저장하고 계산했다. 우리가 십진법에서 분수 $1/3$을 $0.333...$처럼 무한 소수로밖에 표현하지 못하는 것과 마찬가지로, 컴퓨터는 이진법으로 $1.45$와 같은 특정 십진 소수를 정확하게 표현하지 못했다.

따라서 `rate = 1.45` 코드 실행 시, 컴퓨터는 $1.45$와 가장 가까운 이진수 **근사값**을 메모리에 저장했다. 이 과정에서 눈에 보이지 않는 아주 작은 오차가 처음부터 발생한 것이다.

#### 2. 계산 과정에서의 오차 전파
이렇게 처음부터 미세한 오차를 포함한 값으로 `rate * seconds / 60` 같은 연산을 수행하니, 그 계산 결과 역시 정확한 값($5.365$)이 아닌, 오차가 포함된 근사값($5.364999...$)으로 나왔다.

#### 3. `round()` 함수의 동작 원리
`round()` 함수는 프로그래머가 기대하는 이상적인 값이 아니라, 변수에 **실제로 저장된 값**을 기준으로 동작했다.

`cost` 변수에 들어있는 값은 $5.364999...$였고, `round(cost, 2)`는 이 값을 소수점 둘째 자리까지 반올림하려 했다. 이때 기준이 되는 소수점 셋째 자리 숫자는 '4'였다. 반올림 규칙에 따라 4는 버려지므로, 최종 결과는 $5.36$이 되었다.

이 모든 현상은 특정 언어나 프로그램의 오류가 아닌, 컴퓨터가 부동소수점을 처리하는 방식의 근본적인 한계 때문에 발생했다. 바로 이러한 이유로 금융 계산처럼 아주 작은 오차도 허용되지 않는 분야에서는 부동소수점(`float`) 대신 `Decimal` 타입을 사용하여 계산의 정확성을 보장한다.
