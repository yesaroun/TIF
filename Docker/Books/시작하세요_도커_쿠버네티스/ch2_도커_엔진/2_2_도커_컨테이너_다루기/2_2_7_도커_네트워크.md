도커는 컨테이너 내부의 IP를 순차적으로 할당하며, 이 IP는 컨테이너를 재시작할 때마다 변경될 수 있다.

이 내부 IP는 도커가 설치된 호스트, 즉 내부 망에서만 쓸 수 있는 IP

컨테이너를 시작할때마다 호스트에 veth… 라는 네트워크 인터페이스를 생성한다.(veth에서 v는 vertual을 뜻한다. 즉, virtual eth라는 의미)

veth 인터페이스뿐 아니라 docker0 이라는 브리지도 존재하는데 docker0 브리지는 각 veth 인터페이스와 바인딩돼 호스트의 eth0 인터페이스와 이어주는 역할을 한다.

# 2.2.7.2 도커 네트워크 기능

컨테이너를 생성하면 기본적으로 docker0 브리지를 통해 외부와 통신할 수 있는 환경을 사용할 수 있지만, 사용자의 선택에 따라 여러 네트워크 드라이버를 쓸 수도 있다.

도커가 제공하는 대표적인 네트워크 드라이버: 브리지(bridge), 호스트(host), 논(none), 컨테이너(container), 오버레이(overlay)

이번 장에서는 도커 자체만으로 손쉽게 쓸 수 있는 브리지, 호스트, 논 컨테이너를 설명

네트워크 목록 확인

```bash
docker network ls
>>>
NETWORK ID     NAME              DRIVER    SCOPE
54fcf80916ce   backend_default   bridge    local
e14b06b5c319   bridge            bridge    local
74dc94628a05   host              host      local
5ec06d979539   mybridge          bridge    local
11ab995a6499   none              null      local
```

브리지 네트워크: 컨테이너를 생성할 때 자동으로 연결되는 docker0 브리지를 활용하도록 설정돼 있다.
이 네트워크는 172.17.0.x IP 대역을 컨테이너에 순차적으로 할당

```bash
docker network inspect bridge
>>>
[
    {
        "Name": "bridge",
...
        "EnableIPv6": false,
        "IPAM": {
            "Driver": "default",
            "Options": null,
            "Config": [
                {
                    "Subnet": "172.17.0.0/16",
                    "Gateway": "172.17.0.1"
                }
            ]
        },
...
        "Containers": {},
        "Labels": {}
    }
]
```

해당 명령어로 네트워크의 자세한 정보를 볼 수 있다.
`docker inspect —type network`  동일한 명령어

브리지 네트워크를 사용 중인 컨테이너의 목록을 `Containers` 항목에서 확인 가능
아무런 설정을 하지 않고 컨테이너를 생성하면 컨테이너는 자동으로 docker0 브리지 사용

## 브리지 네트워크

브리지 네트워크는 docker0이 아닌 사용자 정의 브리지를 새로 생성해 각 컨테이너에 연결하는 네트워크 구조이다.
컨테이너는 연결된 브리지를 통해 외부와 통신할 수 있다.

다음과 같이 새로운 브리지 네트워크 생성

```bash
docker network create --driver bridge mybridge
```

다음과 같이 mybridge 네트워크를 사용하는 컨테이너 생성

```bash
docker run -i -t --name mynetwork_container \   
--net mybridge \
ubuntu:24.04
```

컨테이너내부에서 ifconfig를 입력하면 새로운 IP 대역이 할당된 것을 알 수 있다. 브리지 타입의 네트워크를 생성하면 도커는 IP 대역을 차례대로 할당한다.(여기서는 172.19 대역의 내부 IP 할당)

```bash
ifconfig
>>>
eth0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 172.19.0.2  netmask 255.255.0.0  broadcast 172.19.255.255
        ...
```

이렇게 생성된 사용자 정의 네트워크는 docker network disconnect, connect를 통해 컨테이너에 유동적으로 붙이고 뗄 수 있다.

```bash
docker network disconnect mybridge mynetwork_container
docker network connect mybridge mynetwork_container
```

단 위에 명령어는 논 네트워크, 호스트 네트워크 등과 같은 특별한 네트워크 모드에는 사용할 수 없다.

네트워크 서브넷, 게이트웨이, IP 할당 범위 등을 임의로 설정하려면 네트워크를 생성할 때 아래와 같이 `--subnet`, `--ip-range` , `--gateway` 옵션을 추가. 단, `--subnet` 과 `--ip-range` 는 같은 대역이어야 한다.

```bash
docker network create --driver=bridge \ 
--subnet=172.72.0.0/16 \
--ip-range=172.72.0.0./24 \
--gateway=172.72.0.0.1 \
my_custom_network
```

## 호스트 네트워크

네트워크를 호스트로 설정하면 호스트의 네트워크 환경을 그대로 사용
별도로 생성할 필요 없이 기존의 host 라는 이름의 네트워크 사용

```bash
docker run -i -t --name network_host \
--net host \
ubuntu:24.04
```

—net 옵션을 입력해 호스트를 설정
ifconfig 사용하면 호스트와 동일한것 확인 가능

## 논 네트워크

none은 말 그대로 아무런 네트워크를 사용하지 않는 것

```bash
docker run -i -t --name network_none \
--net none \
ubuntu:24.04
```

## 컨테이너 네트워크

다른 컨테이너의 네트워크 네임스페이스 환경을 공유할 수 있다.
공유되는 속성은 내부 IP, 네트워크 인터페이스의 맥(MAC) 주소 등

```bash
docker run -i -t -d --name network_container_1 ubuntu:24.04     
>>>  
d1b6862ec623a5a1eec7ae2f64b2daf6edf7fb4f8f7d55cf25eafb5ac7705711
```

```bash
docker run -i -t -d --name network_conatiner_2 \
--net container:network_container_1 \
ubuntu:24.04
>>>
03d81714976b745930c5311ebe0f08f77a0b6fad266b243fb850dddedb95648c
```

이렇게 다른 컨테이너의 네트워크 환경을 공유하면 내부 IP를 새로 할당받지 않으며 호스트에 veth로 시작하는 가상 네트워크 인터페이스도 생성되지 않는다.
network_container_2 컨테이너의 네트워크와 관련된 사항은 전부 network_container_1 과 같게 설정된다.

```bash
exec network_container_1 ifconfig       
>>>
eth0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 65535
        inet 172.17.0.2  netmask 255.255.0.0  broadcast 172.17.255.255
        ...
```

```bash
docker exec network_container_2 ifconfig
eth0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 65535
        inet 172.17.0.2  netmask 255.255.0.0  broadcast 172.17.255.255
        ...
```

## 브리지 네트워크와 --net-alias

브리지 타임의 네트워크와 run 명령어의 --net-alias 옵션을 함께 쓰면 특정 호스트 이름으로 컨테이너 여러 개에 접근할 수 있다.
위에서 생성한 mybridge 네트워크를 이용해 컨테이너 3개를 생성해 보자.
--net-alias 옵션의 값은 alicek106으로 설정했으며, 다른 컨테이너에서 alicek106이라는 호스트 이름으로 아래 3개의 컨테이너에 접근할 수 있다.

```bash
docker run -i -t -d --name network_alias_container1 \
--net mybridge \
--net-alias alicek106 ubuntu:24.04

docker run -i -t -d --name network_alias_container2 \
--net mybridge \
--net-alias alicek106 \
ubuntu:24.04

docker run -i -t -d --name network_alias_container3 \
--net mybridge \
--net-alias alicek106 \
ubuntu:24.04
```

inspect 명령어로 각 컨테이너의 IP를 확인해보자.

```bash
docker inspect network_alias_container1 | grep IPAddress
>>>
            "SecondaryIPAddresses": null,
            "IPAddress": "",
            "IPAddress": "172.19.0.2",
```

첫 번째 컨테이너의 IP 주소가 172.19.0.2이므로 두 번째, 세 번째 컨테이너는 각각 172.19.0.3, 172.19.0.4 일 것이다. 세 개의 컨테이너에 접근할 컨테이너를 생성한 뒤 alicek106이라는 호스트 이름으로 ping 요청을 전송해보자.

```bash
docker run -i -t --name network_alias_ping \
--net mybridge \
ubuntu:24.04
>>> 컨테이너 내부

ping -c 1 alicek106
>>>
PING alicek106 (172.19.0.2) 56(84) bytes of data.
64 bytes from network_alias_container2.mybridge (172.19.0.2): icmp_seq=1 ttl=64 time=0.252 ms
...

ping -c 1 alicek106
>>>
PING alicek106 (172.19.0.3) 56(84) bytes of data.
64 bytes from network_alias_container2.mybridge (172.19.0.3): icmp_seq=1 ttl=64 time=0.252 ms
...

ping -c 1 alicek106
>>>
PING alicek106 (172.19.0.4) 56(84) bytes of data.
64 bytes from network_alias_container2.mybridge (172.19.0.4): icmp_seq=1 ttl=64 time=0.252 ms
...
```


컨테이너 3개의 IP로 각각 ping이 전송된 것을 확인할 수 있다. 매번 달라지는 IP를 결정하는 것은 별도의 알고리즘이 아닌 라운드 로빈(round-robin) 방식(하나의 중앙처리장치를 여러 프로세스들이 우선순위 없이 돌아가며 할당받아 실행되는 방식)이다. 이것이 가능한 이유는 도커 엔진에 내장된 DNS가 alicek106이라는 호스트 이름을 —net-alias 옵션으로 alicek106을 설정한 컨테이너로 변환(resolve)하기 때문이다.

도커의 DNS는 호스트 이름으로 유동적인 컨테이너를 찾을 때 주로 사용
대표적인 예: --link 옵션 → 컨테이너의 IP가 변경돼도 별명으로 컨테이너를 찾을 수 있게 DNS에 의해 자동으로 관리. 단, 이 경우는 디폴트 브리지 네트워크의 컨테이너 DNS라는 점이 다르다.

`--net-alias` 옵션 또한 `--link` 옵션과 비슷한 원리
도커는 기본 브리지 네트워크가 아닌 사용자가 정의한 브리지 네트워크에 사용되는 내장 DNS 서버를 가지며, DNS의 IP는 127.0.0.11 
mybribge 라는 이름의 네트워크에 속한 3개의 컨테이너는 run으로 생성할 때 `--net-alias` 옵션에 alicek106이라는 값을 입력했으며, 이 컨테이너의 IP는 DNS 서버에 alicek106이라는 호스트 이름으로 등록된다.

mybridge 네트워크에 속한 컨테이너에서 alicek106이라는 호스트 이름으로 접근하면 DNS 서버는 라운드 로빈 방식을 이용해 컨테이너의 IP 리스트를 반환

## MacVLAN 네트워크

MacVLAN은 호스트의 네트워크 인터페이스 카드를 가상화해 물리 네트워크 환경을 컨테이너에게 동일하게 제공
→ MacVLAN을 사용하면 컨테이너는 물리 네트워크상에서 가상의 맥(MAC) 주소를 가지며, 해당 네트워크에 연결된 다른 장치와의 통신이 가능해진다.

→ 공유기, 라우트, 스위치와 같은 네트워크 장비에 두 대의 서버가 연결돼 있고, 각 서버는 192.168.0.0/24 대역에서 IP를 동적으로 할당받는다고 가정

MacVLAN을 사용하면 각 컨테이너에 192.168.0.0/24 대역의 IP를 할당할 수 있다. → MacVLAN을 사용하는 컨테이너들과 동일한 IP 대역을 사용하는 서버 및 컨테이너들은 서로 통신이 가능

# 도커 네트워크 개요 및 주요 기능 요약

도커 네트워크의 핵심 특징과 주요 네트워크 타입을 요약하면 다음과 같습니다

### 기본 네트워크 구조

- 컨테이너는 내부 IP를 순차적으로 할당받으며, 재시작 시 변경될 수 있음
- 호스트에 veth 가상 네트워크 인터페이스 생성
- docker0 브리지가 veth 인터페이스와 호스트의 eth0 연결

### 주요 네트워크 드라이버

- **브리지(bridge)**: 기본 네트워크 모드, docker0 또는 사용자 정의 브리지 사용
- **호스트(host)**: 호스트의 네트워크 환경을 그대로 사용
- **논(none)**: 네트워크를 사용하지 않음
- **컨테이너(container)**: 다른 컨테이너의 네트워크 환경 공유
- **MacVLAN**: 물리 네트워크 환경을 컨테이너에 직접 제공

### 네트워크 관리 명령어

- `docker network ls`: 네트워크 목록 확인
- `docker network inspect`: 네트워크 상세 정보 확인
- `docker network create`: 새 네트워크 생성
- `docker network connect/disconnect`: 네트워크 연결/해제

## 도커 네트워크 관련 명령어 정리

### 기본 네트워크 관리

- `docker network ls` - 도커 네트워크 목록 확인
- `docker network inspect [네트워크명]` - 특정 네트워크의 상세 정보 확인
    - 동일한 기능: `docker inspect --type network [네트워크명]`

### 네트워크 생성 및 관리

- `docker network create --driver bridge [네트워크명]` - 브리지 타입 네트워크 생성
- `docker network create --driver=bridge --subnet=172.72.0.0/16 --ip-range=172.72.0.0./24 --gateway=172.72.0.0.1 [네트워크명]` - 세부 설정이 포함된 커스텀 네트워크 생성
- `docker network disconnect [네트워크명] [컨테이너명]` - 컨테이너에서 네트워크 연결 해제
- `docker network connect [네트워크명] [컨테이너명]` - 컨테이너에 네트워크 연결

### 컨테이너 실행 (네트워크 옵션 포함)

- `docker run -i -t --name [컨테이너명] --net [네트워크명] [이미지명]` - 지정된 네트워크로 컨테이너 실행
- `docker run -i -t --name [컨테이너명] --net host [이미지명]` - 호스트 네트워크 모드로 컨테이너 실행
- `docker run -i -t --name [컨테이너명] --net none [이미지명]` - 네트워크 없이 컨테이너 실행
- `docker run -i -t --name [컨테이너명] --net container:[다른컨테이너명] [이미지명]` - 다른 컨테이너의 네트워크 환경 공유
- `docker run -i -t --name [컨테이너명] --net [네트워크명] --net-alias [별칭] [이미지명]` - 네트워크 별칭 설정

### 컨테이너 내부 확인

- `docker exec [컨테이너명] ifconfig` - 컨테이너 내부 네트워크 인터페이스 정보 확인
- `docker inspect [컨테이너명] | grep IPAddress` - 컨테이너의 IP 주소 확인