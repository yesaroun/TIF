네임스페이스(Namespace): 리소스를 논리적으로 구분하는 장벽(7.1)

쿠버네티스에서는 리소스를 논리적으로 구분하기 위해 네임스페이스(Namespace)라는 오브젝트를 제공.  
간단히 네임스페이스는 pod, replicaset, deployment, service 등과 같은 kubernetes 리소스들이 묶여 있는 가상 공간 또는 그롭이다.

예  
모니터링을 위한 리소스들은 monitoring 이라는 namespace에서 생성할 수 있고,  
테스트를 위한 리소스들은 testbed라는 namespace에서 생성할 수 있다.  
또는 여러 개발 조직이 하나의 kubernetes cluster를 공유해야한다면 조직별로 namespace를 사용하도록 구성할 수도 있다.

# Namespace 기본 개념 이해

```bash
kubectl get namespace  # namespace 목록 확인 가능
kubectl get ns  
---
NAME                STATUS      AGE
default             Active      16m
kube-node-lease     Active      16m
kube-public         Active      16m
kube-system         Active      16m
```

namespace를 생성하지 않았더라도 기본적으로 4개의 네임스페이스가 존재한다. 각 네임스페이스는 논리적인 리소스 공간이기 때문에 각 네임스페이스에는 파드, 레플리카셋, 서비스와 같은 리소스가 따로 존재한다. 예를 들어 default namespace에 생성된 pod를 확인해보겠다.

```bash
kubectl get pods --namespace default
---
NAME                                READY   STATUS      RESTARTS    AGE 
hostname-deployment-84323222-3fds   1/1     Running     0           3m20s
hostname-deployment-84223032-fdms   1/1     Running     0           3m20s
hostname-deployment-84223032-8jsf   1/1     Running     0           3m20s
```

default는 쿠버네티스를 설치하면 자동으로 사용되도록 설정되는 namespace로 kubectl 명령어로 kubernetes 리소스를 사용할 때는 기본적으로 default namespace를 사용한다. 즉, `--namespace` 옵션을 명시하지 않으면 기본적으로 default 네임스페이스를 사용한다.

kube-system이라는 namespace의 pod도 확인해보겠다.

```bash
kubectl get pods -n kube-system  # --namespace 대신 -n 옵션으로도 사용 가능
---
NAME                        READY   STATUS      RESTARTS    AGE
coredns-84c3232-82sff       1/1     Running     0           29m
...
```

이전에 생성한 적 없는 pod가 여러 개 실행되고 있다. kube-system namespace는 kubernetes cluster 구성에 필수적인 컴포넌트들과 설정값 등이 존재하는 namespace이다. 지금까지 default namespace 와 논리적으로 구분돼 있기 때문에 이렇게 많은 pod를 보지 못했던 것이다.

각 namespace의 리소스들은 논리적으로만 구분된 것일 뿐, 물리적으로 격리된 것은 아니다.   
예를 들어 서로 다른 namespace에서 생성된 pod 가 같은 node에 존재할 수도 있다.

### 네임스페이스와 라벨의 차이
라벨 또한 리소스를 분류하고 구분하기 위한 방법이다. 예를 들어 `app=webserver`라는 라벨을 가지는 pod만 출력하려면 다음과 같이 `-l` 옵션을 사용할 수 있다.

```bash
kubectl get pods -l app=webserver
```

namespace는 labbel 보다 더 넓은 용도로 사용할 수 있다.  
예를 들어 ResourceQuota라는 object를 이용해 특정 namespace에서 생성되는 pod의 자원 사용량을 제한하거나, 애드미션 컨트롤러라는 기능을 이용해 특정 namespace에서 상성되는 파드에는 항상 사이드케 컨테이너를 붙이도록 설정할 수 있다.  
무엇보다도 kubernetes에서 사용 목적에 따라 pod, service 등의 리소스를 격리함으로써 편리하게 구분할 수 있다는 특징도 있다.

# Namespace 사용하기

chapter7/production-namespace.yaml

```yaml
apiVersion: v1
kind: Namespace
metadata:
  name: production
```

```bash
kubectl apply -f production-namespace.yaml
---
namespace/production created
```

또는 `kubectl create namespace` 명령어로 쉽게 생성할 수 있다.

```bash
kubectl create namespace production
---
namespace/mynamespace created
```

namespace의 목록을 확인하면 production이라는 namespace가 새롭게 생성돼 있다.

```bash
kubectl get ns | grep production
---
production  Active      62s
```

특정 namespace에 리소스를 생성하는 방법은 간단하다. 예를 들어 production namespace에 deployment와 service를 생성하려면 yaml파일에서 `metadata.namespace` 항목을 아래와 같이 설정하면 된다.

chapter7/hostname-deploy-svc-ns.yaml

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: hostname-deployment-ns
  namespace: production
spec:
...
---
apiVersion: v1
kind: Service
metadata:
  name: hostname-svc-clusterip-ns
  namespace: production
spec:
...
```

위의 yaml 파일을 생성하면 production namespace에 service, deployment가 생성된다.

```bash
kubectl apply -f hostname-deploy-svc-ns.yaml
---
deployment.apps/hostname-deployment-ns created
service/hostname-svc-clusterip-ns created

kubectl get pods, services -n production
---
NAME                                        READY   STATUS      RESTARTS    AGE
pod/hostname-deployment-ns-38201-t212       1/1     Running     0           3m58s

NAME                                        TYPE        CLUSTER-IP      EXTERNAL-IP PORT(S)     AGE
service/hostname-deployment-svc-cluster-ns  ClusterIP   10.96.108.196   <none>      8080/TCP    3m58s
```

`--all-namespaces` 옵션을 사용하면 모든 namespace의 리소스를 확인할 수 있다.

```bash
kubectl get pods --all-namespaces
```

# Namespace의 서비스에 접근하기

서비스 오브젝트를 설명할 때, kubernetes cluster 내부에서는 service 이름을 통해 파드에 접근할 수 있다고 설명했다. 이는 정확히 말하자면 '같은 namespace 내의 service'에 접근할때에는 service 이름만으로 접근할 수 있다는 뜻이다.

그래서 `<service name>.<namespace name>.svc`처럼 작성하면 다른 namespace의 service도 접근할 수 있다. 예를 들어 production namespace에 있는 hostname-svc-clusterip-ns 라는 이름의 service에는 다음과 같이 접근할 수 있다.

```bash
root@debug:/# curl hostname-svc-clusterip-ns.production.svc:8080 --slient | grep Hello
    <p>Hello, hostname-deployment-ns-6948384-t4872</p>    </blockquote>
```

| 서비스의 DNS 이름에 대한 FQDN(Fully Qualified Domain Name)은 일반적으로 다음과 같은 형식으로 구성돼 있다.
| `<service name>.<namespace name>.svc.cluster.local`

namespace는 `kubectl delete -f <YAML 파일명>` 또는 `kubectl delete namespace` 명령어로 간단히 삭제할 수 있다. 단, namespace에 존재하는 모든 리소스 또한 함께 삭제되기 때문에 namespace를 삭제하기 전에는 다신 한번 리소스 목록을 확인해 보는 것이 좋다.

```bash
kubectl delete namespace production
---
namespace "production" deleted
```

# Namespace에 종속되는 kubernetes object와 독립적인 object

Namespace를 사용하면 kubernetes 리소르를 사용 목적에 따라 논리적으로 격리할 수 있지만, 모든 리소스가 namespace에 의해 구분되는 것은 아니다.

pod, service, replicaset, deployment는 namespace 단위로 구분할 수 있다. 예를 들어 A라는 namespace에서 pod를 만들면 A namespace에서만 보이고, B namespace에서는 보이지 않을 것이다. 이런 경우를 kubernetes에서는 'object가 namespace에 속한다(namespaced)'라고 표현한다. namespace에 속하는 object 종류는 다음 명령어로 확인할 수 있다.

```bash
kubectl api-resources --namespaced=true
---
NAME            SHORTNAMES  APIVERSION  NAMESPACED  KIND
bindings                    v1          true        Binding
configmaps      cm          v1          true        ConfigMap
...
pods            po          v1          true        Pod
```

이와 반대로 namespace에 속하지 않는 kubernetes object도 있다. nodes 또한 kubernetes object 중 하나지만 namespace에 속하지 않는 대표적인 object 중 하나이다. 따라서 `kubectl get nodes` 명령어에 `--namespace` 옵션을 추가해도 의미가 없다. nodes는 kubernetes cluster 에서 사용되는 저수준의 object이며, namespace에 의해 구분되지 않기 때문이다.

namespace에 속하지 않는 object 종류는 다음 명령어로 확인할 수 있다.

```bash
kubectl api-resources --namespaced=false
---
NAME            SHORTNAMES  APIVERSION  NAMESPACED  KIND
namespaces      ns          v1          false       Namespace
nodes           no          v1          false       Node
...
```

