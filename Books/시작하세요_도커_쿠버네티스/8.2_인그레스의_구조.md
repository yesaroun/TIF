8.2 Ingress의 구조

`kubectl get ingress` 명령어로 Ingress의 목록을 확인할 수 있다.

```bash
$ kubectl get ingress
$ kubectl get ing  # ing라는 이름으로도 사용 가능
No resources found.
```

간단한 Ingress를 생성해보겠다.

예제 8.1 chapter8/ingress-example-k8s-latest.yaml

```yml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: ingress-example
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
spec:
  ingressClassName: nginx
  rules:
  - host: alicek106.example.com  # [1]
    http:
      paths:
      - path: /echo-hostname  # [2]
        pathType: Prefix
        backend:
          service:
            name: hostname-service  # [3]
            port:
              number: 80
```

[1] host: 해당 도메인 이름으로 접근하는 요청에 대해 처리 규칙을 적용한다. 위 예시는 alicek106.example.com 이라는 도메인으로 접근하는 요청만 처리하지만, 여러 개의 host를 정의해 사용할 수도 있다.
[2] path: 해당 경로에 들어온 요청을 어느 서비스로 전달할 것인지 정의한다. 위 예시에서는 `/echo-hostname`이라는 경로의 요청을 bakcend에 정의된 서비스로 전달한다. 여러 개의 path를 정의해 경로를 처리할 수도 있다.
[3] name, port: path로 들어온 요청이 전달될 서비스와 포트이다. 즉 위 예시에서는 `/echo-hostname`이라는 경로로 들어온 요청을 hostname-service 서비스의 80 포트로 전달한다.

```bash
$ kubectl apply -f ingress-example-k8s-latest.yaml
ingress.networking.k8s.io/ingress-example created

$ kubectl get ingress
NAME            CLASS   HOSTS                   ADDRESS     PORTS       AGE
ingress-example nginx   alicek106.example.come              80          6s
```

ingress-example이라는 이름의 Ingress를 생성했지만, 이것만으로는 아무 일도 일어나지 않는다. Ingress는 단지 요청을 처리하는 규칙을 정의하는 선언적인 Object일뿐, 외부 요청을 받아들일 수 있는 실제 서비스가 아니기 때문이다. Ingress는 Ingress Controller 라고 하는 특수한 서버에 적용해야지만 그 규칙을 사용할 수 있다. 즉, 실제로 외부 요청을 받아들이는 것은 Ingress Controller Server이며, 이 Server가 Ingress 규칙을 로드해 사용한다.

따라서 Kubernetes의 Ingress는 반드시 Ingress Controller라는 서버와 함께 사용해야 한다. Ingress Controller Server는 여러 종류가 있으면 필요에 따라 하나를 골라 사용하면 된다. 대표적으로는 Nginx Web Server Ingress Controller가 있다. 그 외에도 Konge 이라는 API GateWay나 GKE 등의 Cloud Platform에서 제공되는 Ingress Controller가 있지만, 이번 장에는 Nginx Ingress Controller를 사용해 보겠다.

Nginx Ingress Controller는 Kubernetes에서 공식적으로 개발되고 있기 때문에 설치를 위한 YAML 파일을 공식 Github에서 직접 내려받을 수 있다. 아래 명령어를 실행하면 Nginx Ingress Controller와 관련된 모든 리소스를 한 번에 설치할 수 있다.

```bash
$ kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.12.1/deploy/static/provider/cloud/deploy.yaml

namespace/ingress-nginx created
serviceaccount/ingress-nginx created
serviceaccount/ingress-nginx-admission created
role.rbac.authorization.k8s.io/ingress-nginx created
```

명령어의 출력 결과에서 알 수 있듯이 Nginx Ingress Controller를 설치하기 위해 다양한 Kubernetes 리소스를 한 번에 생성한다. ingress-nginx 라는 Namespace에 Nginx Web Server Deployment를 생성하고, 그와 관련된 설정들을 Configmap으로 생성하는 것을 알 수 있다.

시간이 지난 뒤 ingress-nginx Namespace의 Deployment와 Pod를 확인해보면 Nginx Web Server가 생성돼 있을 것이다.

```bash
$ kubectl get pods, deployment -n ingress-nginx
NAME                                        READY   STATUS      RESTARTS    AGE
pod/ingress-nginx-admission-create-kx22l    0/1     Completed   0           23m
pod/ingress-nginx-admission-pathc-zn9l7     0/1     Completed   0           23m
pod/ingress-nginx-controller-6653jf-l382    1/1     Running     0           23m

NAME                                        READY   UP-TO-DATE  AVAILABLE   AGE
deployment.apps/ingress-nginx-controller    1/1     1           1           23mA
```

외부에서 Nginx Ingress Controller에 접근하기 위한 Service도 생성됐을 것이다.

```bash
$ kubectl get svc
NAME                                TYPE            CLUSTER-IP      EXTERNAL-IP                 ...
ingress-nginx-controller            LoadBalancer    100.66.64.61    a20..2.elb.amazonaws.com    ...
ingress-nginx-controller-admission  ClusterIP       100.71.133.142  ...
```

Nginx Ingress Controller를 설치하면 자동으로 생성되는 Service는 LoadBalancer 타입이며, 위 예시는 AWS에서 생성된 예시이다. 실제 운영 환경이라면 LoadBalancer Type에 DNS 이름을 할당함으로써 Nginx Ingress Controller에 접근하는 것이 일반적이지만 일단 지금은 자동으로 부여된 DNS 이름(a20..2.elb.amazonaws.com)을 사용해 보겠다.

하지만 가상 머신처럼 Cloud가 아닌 환경에서 Ingress를 테스트하고 싶다면 LoadBalancer 대신 NodePort Type의 Service를 생성해 사용해도 된다. 이 경우에는 각 Node의 Random한 Port로 Nginx Ingress Controller에 접근할 수 있다.

예제 8.2 chapter8/ingress-nginx-svc-nodeport.yaml

```yml
apiVersion: v2
kind: Service
metadata:
  name: ingress-nginx-controller-nodeport
  namespace: ingress-nginx
spec:
  prots:
  - name: http
    nodePort: 31000
    port: 80
    protocol: TCP
    targetPort: http
  - name: https
    nodePort: 32000
    port: 443
    protocol: TCP
    targetPort: https
  selector:
    app.kubernetes.io/component: controller
    app.kubernetes.io/instance: ingress-nginx
    app.kubernetes.io/name: ingress-nginx
  type: NodePort
```

혹은 온프레미스에서의 운영 단계를 계획하고 있다면 MetalLB나 오픈스택의 로드 밸런서를 사용할 수도 있다.

이로써 Ingress, Nginx Ingress Controller 및 Nginx Pod 에 접근하기 위한 Service의 준비가 완료되었으나, 아직 Ingress의 종착점이 될 테스트용 Deployment와 Service를 생성하지 않았으므로(echo-hostname) 이를 생성해 최종적으로 Ingress의 동작 여부를 확인해보겠다. Nginx Ingress Controller로 들어오는 요청은 이 Deployment의 Pod로 분산될 것이다.

hostname-deployment.yaml

```yml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: hostname-deployment
spec:
  replicas: 3
  selector:
    matchLabels:
      app: webserver
  template:
    metadata:
      name: my-webserver
      labels:
        app: webserver
    spec:
      containers:
      - name: my-webserver
        image: alicek106/ingress-annotation-test:0.0
        ports:
        - containerPort: 5000
          name: flask-port
```

hostname-service.yaml

```yml
apiVersion: v1
kind: Service
metadata:
  name: hostname-service
spec:
  ports:
    - name: web-port
      port: 80
      targetPort: flask-port
  selector:
    app: webserver
  type: ClusterIP
```

```bash
$ kubectl apply -f hostname-deployment.yaml
deployment.apps/hostname-deployment created

$ kubectl apply -f hostname-service.yaml
service/hostname-service created
```

```bash
$ kubectl get pods, services
NAME                                READY   STATUS  RESTARTS    AGE
pod/hostname-deployment-6933-8qsng  1/1     Running 0           3m26s
pod/hostname-deployment-6933-sbrxb  1/1     Running 0           3m26s
pod/hostname-deployment-6933-shrzz  1/1     Running 0           3m26s

NAME                        TYPE        CLUSTER-IP      EXTERNAL-IP PORT(S)     AGE
service/hostname-service    ClusterIP   10.110.123.63   <none>      8080/TCP    3m21s
...
```

Ingress Controller에 의해 요청이 최종적으로 도착할 Deployment의 Service는 어떤 타입이든지 상관은 없습니다. 다만 굳이 외부에 서비스를 노출할 필요가 없다면 ClusterIP 타입을 사용하는 것이 좋습니다.

Nginx Ingress Controller의 `/echo-hostname`으로 요청을 전송해보겠습니다. AWS를 사용하고 있다면 DNS 이름으로, GKE라면 IP 이름으로 접근합니다.

```bash
$ curl a20..2.elb.amazonaws.com/echo-hostnameA
<html>
<head><title>404 Not Found</title></head>
...
```

이상하게도 404 에러가 반환됐습니다. 이는 이전에 Ingress를 생성할 때 Nginx Ingress Controller에 alicek106.example.com으로 접근했을때만 응답을 처리하도록 설정했기 때문입니다. 따라서 alicek106.example.com이 아닌 다른 도메인 이름으로 접근할 때는 Nginx Ingress Controller가 해당 요청을 처리하지 않습니다.

```yml
...
spec:
  rules:
  - host: alicek106.example.com
    http:
...
```

Nginx에 접근하기 위한 LoadBalancer 타입의 서비스를 생성했을때, GKE에서 부하 분산기의 IP만 할당받았다면 curl 명령어의 `--resolve` 옵션을 통해 임시로 모메인 명을 설정할 수 있다.

```bash
$ curl --resolve alicek106.example.com:80:<부하 분산기 IP> alicek106.example.com/ehco-hostname
$ # 사용 예시
$ curl --resolve alicek106.example.com:80:1.2.3.4 alicek106.example.come/echo-hostname
----
You accessed to path "/"
Access Server URL  : http://alicek106.example.com/
Container Hostname  : hostname-deployemnt-6c97ccbc99-kcr5d
Container IP  : 10.233.86.136
----
```

온프레미스 환경이나 GKE와 같이 IP만 할당받아 사용하고 있다면 `/etc/hosts` 파일에 IP와 도메인을 설정해 임시로 동작 여부를 테스트할 수 있습니다.  

```bash
# Nginx Ingress Controller에 접근할 수 있는 IP가 10.20.30.40인 경우 `/etc/hosts` 파일
...
10.20.30.40 alicek106.example.com
```

NodePort 타입으로 Service를 생성했다면 다음과 같은 명령어로 테스트할 수 있습니다. 아래의 예시는 책에서 제공하는 예제를 사용해 31000 포트로 NodePort Service를 생성한 경우입니다.

```bash
$ curl --resolve alicek106.example.com:31000:<노드 중 하나의 IP를 입력합니다> \
  alicek106.example.com:31000/echo-hostname
...
```

AWS에서 임의의 DNS를 LoadBalancer 타입의 Service에 할당 받았다면 이미 생성된 Ingress 리소스의 정보에서 host 항목을 직접 로드 밸런서의 DNS로 수정해보겠습니다.

```bash
$ kubectl edit ingress ingress-example
...
spec:
  rules:
  - host: a206556...ap-northeast-2.elb.amazonaws.com
    http:
      paths:
      - backend:
...
```

Ingress의 host 항목을 변경했기 때문에 AWS LoadBalancer의 DNS 이름으로 접근할 때도 Nginx Ingress Controller가 해당 요청을 처리할 것이다.

```bash
curl a206556...ap-northeast-2.elb.amazonaws.com/echo-hostname
---
You accessed to path "/"
Access Server URL : alicek106
```











































